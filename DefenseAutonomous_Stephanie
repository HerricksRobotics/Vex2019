#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorRotation)
#pragma config(Sensor, dgtl2,  rightEncoder,   sensorRotation)
#pragma config(Motor,  port1,           leftFront,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftMid,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightMid,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          linLaunch,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*
Defense Autonomous
Stephanie G.
Starting Position: BS1
Points: 0
*/

void driveTrain (int speed) //+speed == forward || -speed == backward; Takes in speed value, and allows drive train to move forward and backward
{
	motor[leftFront] = speed;
	motor[leftMid] = speed;
	motor[leftBack] = speed;
	motor[rightFront] = speed;
	motor[rightMid] = speed;
	motor[rightBack] = speed;
}

/* Defense autonomous does not use the turnCW and turnCCW methods
void turnCW(int speed) //Takes in speed value, and allows drive train to turn clockwise
{
	motor[leftFront] = speed;
	motor[leftMid] = speed;
	motor[leftBack] = speed;
	motor[rightFront] = -speed;
	motor[rightMid] = -speed;
	motor[rightBack] = -speed;
}

void turnCCW(int speed) //Takes in speed value, and allows drive train to turn counter-clockwise
{
	motor[leftFront] = -speed;
	motor[leftMid] = -speed;
	motor[leftBack] = -speed;
	motor[rightFront] = speed;
	motor[rightMid] = speed;
	motor[rightBack] = speed;
}
*/

/* Intake and LinLauncher will not be used in the any of the autonomous sections
void intakeBall(int speed) //Takes in speed value, and allows the intake motor to take in balls
{
	motor[intake] = speed;
}

void shootBall (int speed) //Takes in speed value and sets linLaunch motor to inputted speed
{
	motor[linLaunch] = speed;
}

*/

float distance() //Takes in any of the encoder sensor values and returns the distance traveled by the robot
{
	return 4*PI*(SensorValue[leftEncoder]/360);
}

task main() //MAIN METHOD
{
	SensorValue[in1] = sensorNone; //Reset input 2 slot
	wait1Msec(1000);
	SensorValue[in1] = sensorGyro; //Set input 2 slot as gyro sensor
	wait1Msec(1000);
	SensorValue[gyro] = 0; //resets the gyro encoder sensor value to 0

	SensorValue[leftEncoder] = 0; //resets left encoder sensor value to 0
	SensorValue[rightEncoder] = 0; //resets right encoder sensor value to 0

	//Move forward into the blue and red caps
	while (distance() < 144)
	{
		driveTrain(127); //sets all drivetrain motors at MAX speed
	}
	driveTrain(0); //stops all driveTrain motors


} //end of main method
